#!/usr/bin/env python3
import RPi.GPIO as GPIO
import time
import os
import random
from datetime import datetime
from paho.mqtt import client as mqtt_client

# ============================================
# CONFIGURATION
# ============================================

# --- DHT11 CONFIGURATION ---
DHTPIN = 17  # GPIO pin for DHT11
GPIO.setmode(GPIO.BCM)
MAX_UNCHANGE_COUNT = 100

STATE_INIT_PULL_DOWN = 1
STATE_INIT_PULL_UP = 2
STATE_DATA_FIRST_PULL_DOWN = 3
STATE_DATA_PULL_UP = 4
STATE_DATA_PULL_DOWN = 5

# --- DS18B20 CONFIGURATION ---
ds18b20 = ''

# --- MQTT CONFIGURATION ---
BROKER = "localhost"
PORT = 1883
TOPIC = "metrics"
CLIENT_ID = "rpi-sensor-publisher"
connected = False

# ============================================
# MQTT SETUP
# ============================================

def on_connect(client, userdata, flags, rc, properties=None):
    global connected
    if rc == 0:
        connected = True
        print(f"[MQTT] Connected successfully to {BROKER}:{PORT}")
    else:
        print(f"[MQTT] Connection failed, return code {rc}")

client = mqtt_client.Client(mqtt_client.CallbackAPIVersion.VERSION2, CLIENT_ID)
client.on_connect = on_connect
client.connect(BROKER, PORT)
client.loop_start()

while not connected:
    time.sleep(0.2)

# ============================================
# DHT11 FUNCTIONS
# ============================================

def read_dht11_dat():
    GPIO.setup(DHTPIN, GPIO.OUT)
    GPIO.output(DHTPIN, GPIO.HIGH)
    time.sleep(0.05)
    GPIO.output(DHTPIN, GPIO.LOW)
    time.sleep(0.02)
    GPIO.setup(DHTPIN, GPIO.IN, GPIO.PUD_UP)

    unchanged_count = 0
    last = -1
    data = []

    while True:
        current = GPIO.input(DHTPIN)
        data.append(current)
        if last != current:
            unchanged_count = 0
            last = current
        else:
            unchanged_count += 1
            if unchanged_count > MAX_UNCHANGE_COUNT:
                break

    state = STATE_INIT_PULL_DOWN
    lengths = []
    current_length = 0

    for current in data:
        current_length += 1
        if state == STATE_INIT_PULL_DOWN:
            if current == GPIO.LOW:
                state = STATE_INIT_PULL_UP
        elif state == STATE_INIT_PULL_UP:
            if current == GPIO.HIGH:
                state = STATE_DATA_FIRST_PULL_DOWN
        elif state == STATE_DATA_FIRST_PULL_DOWN:
            if current == GPIO.LOW:
                state = STATE_DATA_PULL_UP
        elif state == STATE_DATA_PULL_UP:
            if current == GPIO.HIGH:
                current_length = 0
                state = STATE_DATA_PULL_DOWN
        elif state == STATE_DATA_PULL_DOWN:
            if current == GPIO.LOW:
                lengths.append(current_length)
                state = STATE_DATA_PULL_UP

    if len(lengths) != 40:
        return None

    shortest_pull_up = min(lengths)
    longest_pull_up = max(lengths)
    halfway = (longest_pull_up + shortest_pull_up) / 2
    bits = []
    the_bytes = []
    byte = 0

    for length in lengths:
        bit = 1 if length > halfway else 0
        bits.append(bit)

    for i in range(len(bits)):
        byte = (byte << 1) | bits[i]
        if (i + 1) % 8 == 0:
            the_bytes.append(byte)
            byte = 0

    checksum = (the_bytes[0] + the_bytes[1] + the_bytes[2] + the_bytes[3]) & 0xFF
    if the_bytes[4] != checksum:
        return None

    return the_bytes[0], the_bytes[2]  # humidity, temperature

# ============================================
# DS18B20 FUNCTIONS
# ============================================

def setup_ds18b20():
    global ds18b20
    base_dir = '/sys/bus/w1/devices'
    for i in os.listdir(base_dir):
        if i.startswith('28-'):
            ds18b20 = i
            break

def read_ds18b20():
    if ds18b20 == '':
        return None

    location = f'/sys/bus/w1/devices/{ds18b20}/w1_slave'
    try:
        with open(location, 'r') as tfile:
            text = tfile.read()
        secondline = text.split("\n")[1]
        temperaturedata = secondline.split(" ")[9]
        temperature = float(temperaturedata[2:]) / 1000
        return temperature
    except Exception:
        return None

# ============================================
# MAIN LOOP
# ============================================

def main():
    print("Raspberry Pi MQTT Publisher\n")
    setup_ds18b20()

    while True:
        dht_result = read_dht11_dat()
        ds18b20_temp = read_ds18b20()
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Construct message payload
        payload = {"timestamp": timestamp}

        # DHT11 readings
        if dht_result:
            humidity, dht_temp = dht_result
            print(f"DHT11 -> Humidity: {humidity}% | Temp: {dht_temp:.1f}°C", end='')
            payload["humidity"] = humidity

        else:
            print("DHT11 -> Read error", end='')
            payload["humidity"] = None
            #payload["dht_temp"] = None

        # DS18B20 readings
        if ds18b20_temp is not None:
            print(f" | DS18B20 -> Temp: {ds18b20_temp:.3f}°C")
            payload["ds18b20_temp"] = ds18b20_temp
        else:
            print(" | DS18B20 -> Read error")
            payload["ds18b20_temp"] = None

        # Publish via MQTT
        client.publish(TOPIC, str(payload))
        print(f"[MQTT] Published to {TOPIC}: {payload}")

        time.sleep(2)

# ============================================
# CLEANUP
# ============================================

def destroy():
    GPIO.cleanup()
    client.loop_stop()
    client.disconnect()

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        destroy()
        print("\nProgram terminated.")
